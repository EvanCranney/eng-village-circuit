REFLECTION

(1) EVALUATION OF SUCCESS

The implementation is successful in that it correctly (i.e. as per the
specifiation) simulates tour group visits to Concurrencia; this is captured
by the simulation output. It remains robust even when the simulation
parameters are varied, and when left to run indefinitely. It is also
successful from a design perspective: the implementation is easy to
understand due to its relative simplicity, but retains potential for
extensibility (see (2) Design Decisions).

(2) CRITICAL DESIGN DECISIONS

  (a) Train Stop Interface - since several classes function as train stops
      (e.g. CableCar, Village), it was sensible to define a TrainStop
      interface. This provides greater extendibility of the simulation
      by leveraging polymorphism; new classes (e.g. Mountain) which also
      function as stops can be accomodated simply by implementing the
      interface. This was preferable to an abstract class for two reasons: 
      firstly the objects implementing TrainStop are conceptually unrelated 
      (CableCar and Village are not subtypes of a common parent); secondly,
      implementations of the leave() and enter() methods vary
      substantially between implementations.

  (b) Monitor/Thread Designation - TrainStop classes have been implemented
      as monitors, and trains as threads. This was done for the sake of
      simplicity. The alternative, with trains as monitors and stops as
      threads is less consonant with the conception of stops as motionless
      objects, and trains as dynamic (i.e. a larger representation gap).
      Stops were not implemented as semaphores (though this would accomodate
      potentially varying numbers of groups at any given stop) because the
      it was judged that the additional extensibility would not outweigh
      the greater complexity.

  (c) Flagging Returning Groups - since CableCar acts as both a stop, and
      the point of contact with the group generator and consumer, it must be
      able to distinguish between groups in the car that have just arrived
      (and are still to visit the villages) and those that are returning
      (after having visited the villages). Failing to do this results in
      the problems identified in (3)(a). This was achieved by adding a flag
      (isReturning) to CableCar instances; this was favourable to the
      alternative (adding a "state" to Group objects) because of its 
      relative simplicity.

(3) INSIGHTS FROM EXPERIMENTATION

  (a) Distinguishing Returning & Departing Groups - failure to add the
      flag described in (2)(c) can result in erroneous group itineraries.
      Groups that arrive at the terminus after visiting the villages may
      then loop around and visit the villages again. Likewise, groups that
      arrive in the valley may be immediately consumed from the car (without
      having visited any villages).

  (b) Potential Deadlock - if enough groups enter Concurrencia such that
      all villages and trains are occupied, and then a new group arrives
      (i.e. appears in the cable car), then the simulation may hit a
      deadlock. No group is able to move from their current location, and
      the consumer will be unable to remove the group from the cable car
      (since it won't have "completed its visit"). To prevent this from
      occuring, this implementation limits the number of groups allowed to
      enter the simulation to 2N+1, where N is the number of stops.
